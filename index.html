<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ğŸ“ å¤šåœ°å€åŸå¸‚åŒ¹é…ç³»ç»Ÿ</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 1200px; margin: auto; }
    #map { width: 100%; height: 500px; margin-top: 20px; }
    .address-block { margin-bottom: 10px; }
    #results, #logs { margin-top: 20px; white-space: pre-wrap; background: #f9f9f9; padding: 15px; border-radius: 8px; }
	@media screen and (max-width: 600px) {
  input[type="text"], input[type="number"] {
    width: 100% !important;
    box-sizing: border-box;
    margin-bottom: 8px;
  }
  .address-block {
    display: block;
  }
  button {
    margin-top: 10px;
    display: block;
    width: 100%;
  }
}

  </style>
</head>
<body>

<h2>ğŸ“ å¤šåœ°å€åŸå¸‚åŒ¹é…ç³»ç»Ÿ</h2>

<!-- API é€‰æ‹©ä¸è¾“å…¥åŒº -->
<div style="border:1px solid #ccc;padding:10px;border-radius:8px;margin-bottom:20px;">
  <label><input type="checkbox" class="api-check" value="amap" checked> ä½¿ç”¨é«˜å¾·åœ°å›¾</label>
  <label><input type="checkbox" class="api-check" value="osm" checked> ä½¿ç”¨OpenStreetMap</label>
  <label><input type="checkbox" class="api-check" value="tencent" checked> ä½¿ç”¨è…¾è®¯ä½ç½®æœåŠ¡</label>
  <label><input type="checkbox" class="api-check" value="geoapify" checked> ä½¿ç”¨Geoapify</label><br>

  <label>é«˜å¾· JS Keyï¼š<input type="text" id="amapJsKeyInput" placeholder="jsKey" value=""></label>
  <label>é«˜å¾· Web Keyï¼š<input type="text" id="amapWebKeyInput" placeholder="webKey" value=""></label><br>
  <label>è…¾è®¯åœ°å›¾ Keyï¼š<input type="text" id="tencentKeyInput" placeholder="è…¾è®¯ Key"></label>
  <label>Geoapify Keyï¼š<input type="text" id="geoapifyKeyInput" placeholder="Geoapify Key"></label><br>
  <button onclick="clearSavedKeys()">ğŸ§¹ æ¸…é™¤å·²ä¿å­˜çš„ Key</button>
</div>

<!-- åœ°å€è¾“å…¥ -->
<div id="addresses">
  <div class="address-block">åœ°å€ 1ï¼š<input type="text" class="addr-input" size="40"></div>
  <div class="address-block">åœ°å€ 2ï¼š<input type="text" class="addr-input" size="40"></div>
</div>

<button onclick="addAddress()">â• æ·»åŠ åœ°å€ï¼ˆæœ€å¤š5ä¸ªï¼‰</button><br><br>
é˜ˆå€¼åŠå¾„ï¼ˆç±³ï¼‰ï¼š<input type="number" id="threshold" value="500">
<button id="matchBtn" onclick="checkMatch()" disabled>å¼€å§‹åŒ¹é…</button>

<h3>ğŸ§ª åŒ¹é…è¿‡ç¨‹æ—¥å¿—</h3>
<div id="logs"></div>

<h3>âœ… åŒ¹é…æˆåŠŸç»“æœ</h3>
<div id="results"></div>

<div id="map"></div>

<div style="margin-top: 30px; font-size: 14px; color: #333;">
  <h4>ğŸ“˜ ä½¿ç”¨è¯´æ˜ï¼š</h4>
  <ul>
    <li>åœ¨ä¸Šæ–¹å‹¾é€‰ä½ è¦ä½¿ç”¨çš„åœ°å›¾æœåŠ¡ã€‚</li>
    <li>å¦‚æœæœåŠ¡éœ€è¦ API Keyï¼Œè¯·åˆ°ä¸‹æ–¹çš„ç”³è¯·åœ°å€ç”³è¯·å¹¶ç²˜è´´ã€‚</li>
    <li>ä½ è¾“å…¥çš„ Key å’Œå‹¾é€‰ä¼šè‡ªåŠ¨ä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ï¼Œä¸‹æ¬¡è‡ªåŠ¨åŠ è½½ã€‚</li>
    <li>æ¨èè‡³å°‘ä½¿ç”¨ 2 ä¸ªåœ°å›¾æœåŠ¡ä»¥è·å¾—æ›´ç¨³å¦¥çš„åŒ¹é…ã€‚</li>
  </ul>
</div>

<!-- API ç”³è¯·å…¥å£ -->
<div style="margin-top: 30px; font-size: 14px; color: #666;">
  <h4>ğŸŒ å„åœ°å›¾æœåŠ¡ API ç”³è¯·åœ°å€ï¼š</h4>
  <ul>
    <li>ğŸ”‘ é«˜å¾·åœ°å›¾ï¼š<a href="https://lbs.amap.com/dev/" target="_blank">https://lbs.amap.com/dev/</a></li>
    <li>ğŸ”‘ è…¾è®¯ä½ç½®æœåŠ¡ï¼š<a href="https://lbs.qq.com/dev" target="_blank">https://lbs.qq.com/dev</a></li>
    <li>ğŸ”‘ Geoapifyï¼š<a href="https://www.geoapify.com/get-started-with-maps-api" target="_blank">https://www.geoapify.com</a></li>
    <li>ğŸ”‘ OpenStreetMap (Nominatim)ï¼š<a href="https://nominatim.org/release-docs/latest/api/Search/" target="_blank">https://nominatim.org</a>ï¼ˆæ— éœ€æ³¨å†Œï¼‰</li>
  </ul>
</div>


<script>

const MAX_ADDR = 5;
const addressCache = new Map();
let map = null;

function loadAmapSDK(jsKey) {
  return new Promise((resolve, reject) => {
    if (window.AMap) {
      resolve();  // å·²åŠ è½½
      return;
    }
    const script = document.createElement("script");
    script.src = `https://webapi.amap.com/maps?v=2.0&key=${jsKey}&plugin=AMap.Geocoder,AMap.Circle,AMap.Marker,AMap.GeometryUtil`;
    script.onload = resolve;
    script.onerror = () => reject(new Error("é«˜å¾·åœ°å›¾ SDK åŠ è½½å¤±è´¥"));
    document.head.appendChild(script);
  });
}


function addAddress() {
  const addrContainer = document.getElementById("addresses");
  const count = document.querySelectorAll(".addr-input").length;
  if (count >= MAX_ADDR) {
    alert("æœ€å¤šåªèƒ½æ·»åŠ 5ä¸ªåœ°å€ï¼");
    return;
  }
  const div = document.createElement("div");
  div.className = "address-block";
  div.innerHTML = `åœ°å€ ${count + 1}ï¼š<input type="text" class="addr-input" size="40">`;
  addrContainer.appendChild(div);
}

function getEnabledAPIs() {
  const checks = document.querySelectorAll(".api-check");
  return Array.from(checks).filter(c => c.checked).map(c => c.value);
}

function saveKeysToLocal() {
  localStorage.setItem("amapJsKey", document.getElementById("amapJsKeyInput").value.trim());
  localStorage.setItem("amapWebKey", document.getElementById("amapWebKeyInput").value.trim());
  localStorage.setItem("tencentKey", document.getElementById("tencentKeyInput").value.trim());
  localStorage.setItem("geoapifyKey", document.getElementById("geoapifyKeyInput").value.trim());
}
function saveCheckedAPIsToLocal() {
  const checks = document.querySelectorAll(".api-check");
  const selected = Array.from(checks).filter(c => c.checked).map(c => c.value);
  localStorage.setItem("enabledAPIs", JSON.stringify(selected));
}

function loadCheckedAPIsFromLocal() {
  const saved = localStorage.getItem("enabledAPIs");
  if (saved) {
    const list = JSON.parse(saved);
    document.querySelectorAll(".api-check").forEach(el => {
      el.checked = list.includes(el.value);
    });
  }
}

function loadKeysFromLocal() {
  ["amapJsKey", "amapWebKey", "tencentKey", "geoapifyKey"].forEach(key => {
    const val = localStorage.getItem(key);
    if (val) document.getElementById(key + "Input").value = val;
  });
}

function clearSavedKeys() {
  ["amapJsKey", "amapWebKey", "tencentKey", "geoapifyKey"].forEach(key => localStorage.removeItem(key));
  alert("å·²æ¸…é™¤æœ¬åœ°ä¿å­˜çš„ Keyï¼Œè¯·åˆ·æ–°é¡µé¢åæŸ¥çœ‹æ•ˆæœã€‚");
}

function bindKeyAutoSave() {
  ["amapJsKeyInput", "amapWebKeyInput", "tencentKeyInput", "geoapifyKeyInput"].forEach(id => {
    document.getElementById(id).addEventListener("input", saveKeysToLocal);
  });
}



window.addEventListener("DOMContentLoaded", async () => {
  loadKeysFromLocal();
  loadCheckedAPIsFromLocal();
  bindKeyAutoSave();
  bindCheckSave();

  const jsKey = document.getElementById("amapJsKeyInput").value.trim();
  if (!jsKey) {
    alert("è¯·å¡«å†™é«˜å¾· JS Key ååˆ·æ–°");
    return;
  }

  try {
    await loadAmapSDK(jsKey);
    map = new AMap.Map("map", {
      zoom: 10,
      center: [116.397428, 39.90923]
    });

    document.getElementById("matchBtn").disabled = false;
  } catch (err) {
    alert("é«˜å¾·åœ°å›¾ SDK åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ JS Key æ˜¯å¦æ­£ç¡®ã€‚");
  }
});


function normalizeCityName(obj) {
  return (obj.city || obj.town || obj.county || obj.state || obj.province || obj.village || "æœªçŸ¥")
    .replace("å¸‚", "").trim();
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function wgs84_to_gcj02(lng, lat) {
  if (out_of_china(lng, lat)) return [lng, lat];
  let dlat = transformlat(lng - 105.0, lat - 35.0);
  let dlng = transformlng(lng - 105.0, lat - 35.0);
  let radlat = lat / 180.0 * Math.PI;
  let magic = Math.sin(radlat);
  magic = 1 - 0.00669342162296594323 * magic * magic;
  let sqrtmagic = Math.sqrt(magic);
  dlat = (dlat * 180.0) / ((6335552.717000426 / (magic * sqrtmagic)) * Math.PI);
  dlng = (dlng * 180.0) / ((6378245.0 / sqrtmagic) * Math.cos(radlat) * Math.PI);
  return [lng + dlng, lat + dlat];
}

function out_of_china(lng, lat) {
  return (lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271);
}

function transformlat(lng, lat) {
  let ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat +
    0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
  ret += (20.0 * Math.sin(6.0 * lng * Math.PI) + 20.0 * Math.sin(2.0 * lng * Math.PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(lat * Math.PI) + 40.0 * Math.sin(lat / 3.0 * Math.PI)) * 2.0 / 3.0;
  ret += (160.0 * Math.sin(lat / 12.0 * Math.PI) + 320 * Math.sin(lat * Math.PI / 30.0)) * 2.0 / 3.0;
  return ret;
}

function transformlng(lng, lat) {
  let ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng +
    0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
  ret += (20.0 * Math.sin(6.0 * lng * Math.PI) + 20.0 * Math.sin(2.0 * lng * Math.PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(lng * Math.PI) + 40.0 * Math.sin(lng / 3.0 * Math.PI)) * 2.0 / 3.0;
  ret += (150.0 * Math.sin(lng / 12.0 * Math.PI) + 300.0 * Math.sin(lng / 30.0 * Math.PI)) * 2.0 / 3.0;
  return ret;
}
function bindCheckSave() {
  document.querySelectorAll(".api-check").forEach(el => {
    el.addEventListener("change", saveCheckedAPIsToLocal);
  });
}

async function fetchAllCandidates(address) {
  const enabledAPIs = getEnabledAPIs();
  const amapWebKey = document.getElementById("amapWebKeyInput").value.trim();
  const tencentKey = document.getElementById("tencentKeyInput").value.trim();
  const geoapifyKey = document.getElementById("geoapifyKeyInput").value.trim();
  const results = [];

  if (enabledAPIs.includes("amap") && amapWebKey) {
    const url = `https://restapi.amap.com/v3/assistant/inputtips?key=${amapWebKey}&keywords=${encodeURIComponent(address)}&datatype=all`;
    const data = await fetch(url).then(res => res.json()).catch(() => null);
    if (data?.tips) {
      results.push(...data.tips.filter(t => t.location && t.district).map(t => ({
        name: t.name,
        city: t.district,
        location: t.location.split(',').map(Number),
        source: "amap"
      })));
    }
  }

  if (enabledAPIs.includes("osm")) {
    await delay(1000);
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&addressdetails=1&limit=1`;
    const res = await fetch(url, { headers: { 'User-Agent': 'MapMatchClient' } }).then(r => r.json()).catch(() => null);
    if (res?.[0]) {
      results.push({
        name: res[0].display_name,
        city: normalizeCityName(res[0].address),
        location: wgs84_to_gcj02(parseFloat(res[0].lon), parseFloat(res[0].lat)),
        source: "osm"
      });
    }
  }

  if (enabledAPIs.includes("tencent") && tencentKey) {
    const url = `https://apis.map.qq.com/ws/geocoder/v1/?address=${encodeURIComponent(address)}&key=${tencentKey}`;
    const data = await fetch(url).then(r => r.json()).catch(() => null);
    if (data?.status === 0) {
      results.push({
        name: address,
        city: data.result.address_components.city,
        location: [data.result.location.lng, data.result.location.lat],
        source: "tencent"
      });
    }
  }

  if (enabledAPIs.includes("geoapify") && geoapifyKey) {
    const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(address)}&format=json&apiKey=${geoapifyKey}`;
    const data = await fetch(url).then(r => r.json()).catch(() => null);
    if (data?.results?.[0]) {
      results.push({
        name: data.results[0].formatted,
        city: normalizeCityName(data.results[0]),
        location: wgs84_to_gcj02(data.results[0].lon, data.results[0].lat),
        source: "geoapify"
      });
    }
  }

  return results;
}

async function checkMatch() {
 if (!map || typeof map.clearMap !== 'function') {
    alert("âš ï¸ åœ°å›¾å°šæœªåˆå§‹åŒ–å®Œæˆï¼Œè¯·ç¨å€™å†è¯•ï¼");
    return;
  }
  const inputs = Array.from(document.querySelectorAll(".addr-input"));
  const threshold = parseFloat(document.getElementById("threshold").value);
  const logsDiv = document.getElementById("logs");
  const resultsDiv = document.getElementById("results");
  logsDiv.innerHTML = "ğŸ” æ­£åœ¨æœç´¢å¹¶å°è¯•åŒ¹é…...\n";
  resultsDiv.innerHTML = "";
  map.clearMap();

  const allInputs = inputs.map(i => i.value.trim());
  if (allInputs.some(val => !val)) {
    logsDiv.innerHTML += "âŒ å­˜åœ¨ç©ºåœ°å€ï¼Œè¯·è¡¥å…¨ã€‚\n";
    return;
  }

  const allCandidates = await Promise.all(allInputs.map(addr => fetchAllCandidates(addr)));
  const cityMatchMap = new Map();

  for (let i = 0; i < allCandidates.length; i++) {
    for (let cand of allCandidates[i]) {
      const city = cand.city.replace("å¸‚", "").trim();
      if (!cityMatchMap.has(city)) {
        cityMatchMap.set(city, Array(allInputs.length).fill(null));
      }
      const arr = cityMatchMap.get(city);
      if (!arr[i]) arr[i] = cand;
    }
  }

  const matchedCities = [];

  for (let [city, points] of cityMatchMap.entries()) {
    logsDiv.innerHTML += `\nğŸ—ºï¸ å°è¯•åŒ¹é…åŸå¸‚ï¼š${city}\n`;
    if (points.includes(null)) {
      const missing = points.map((p, i) => p ? null : allInputs[i]).filter(Boolean);
      logsDiv.innerHTML += `âŒ åŒ¹é…å¤±è´¥ï¼šä»¥ä¸‹åœ°å€æœªåœ¨è¯¥åŸå¸‚æ‰¾åˆ°å€™é€‰ç‚¹ â†’ ${missing.join("ï¼Œ")}\n`;
      continue;
    }

    logsDiv.innerHTML += `ğŸ“ åŒ¹é…ç‚¹ï¼š\n`;
    points.forEach((p, i) => logsDiv.innerHTML += `  - ${allInputs[i]}ï¼š${p.name}ï¼ˆ${p.location.join(",")}ï¼‰ [${p.source}]\n`);

    let valid = true;
    logsDiv.innerHTML += `ğŸ“ è·ç¦»çŸ©é˜µï¼š\n`;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const dist = AMap.GeometryUtil.distance(points[i].location, points[j].location);
        logsDiv.innerHTML += `  - ${allInputs[i]} â†” ${allInputs[j]}ï¼š${dist.toFixed(2)} ç±³\n`;
        if (dist > threshold * 2) valid = false;
      }
    }

    if (valid) {
      logsDiv.innerHTML += `âœ… åŒ¹é…æˆåŠŸï¼šè¯¥åŸå¸‚æ»¡è¶³è·ç¦»æ¡ä»¶ï¼ŒåŠ å…¥å€™é€‰åˆ—è¡¨ã€‚\n`;
      matchedCities.push({ city, points });
    } else {
      logsDiv.innerHTML += `âŒ åŒ¹é…å¤±è´¥ï¼šè·ç¦»è¶…é™ã€‚\n`;
    }
  }

  if (matchedCities.length === 0) {
    resultsDiv.innerHTML = "âŒ æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ»¡è¶³æ¡ä»¶çš„åŸå¸‚ã€‚";
    return;
  }

  const match = matchedCities[0];
  resultsDiv.innerHTML = `<h4>ğŸ åŒ¹é…æˆåŠŸåŸå¸‚ï¼š${match.city}</h4><ul>`;
  const markers = [];

  for (let i = 0; i < match.points.length; i++) {
    const p = match.points[i];
    resultsDiv.innerHTML += `<li>${allInputs[i]}ï¼š${p.name}ï¼ˆ${p.location.join(",")}ï¼‰ [${p.source}]</li>`;
    const marker = new AMap.Marker({ position: p.location, title: p.name, map });
    const circle = new AMap.Circle({
      center: p.location,
      radius: threshold,
      fillColor: '#cceeff',
      strokeColor: '#3399ff',
      fillOpacity: 0.3,
      map
    });
    markers.push(marker, circle);
  }
  resultsDiv.innerHTML += "</ul>";
  map.setFitView(markers);
}


</script>

</body>
</html>
